use super::ast; // super instead of self because lalrpop wraps this in an internal module
use super::spans;


grammar(ctx: &mut spans::SpanMaker<'input>);

Ident: String = <r"[a-z_]\w*"> => String::from(<>);
Tag: String = <r"`[A-Z0-9]\w*"> => String::from(<>);

IntLiteral: String = {
    <r"-?(?:0|[1-9][0-9]*)"> => String::from(<>),
    r"0\d" "Numbers can`t have leading zeros" => "0".to_string(),
};
FloatLiteral: String =
    <r"-?(?:0|[1-9][0-9]*)\.[0-9]*(?:[eE]-?[0-9]+)?"> => String::from(<>);
StringLiteral: String =
    <r#""[^\\"\n\r]*(?:\\[tn'"\\][^\\"\n\r]*)*""#> => String::from(<>);

CommentRest = {
    "*)",
    "Sorry, comments can`t contain *s unless you`re closing them like *)",
};
Comment = {
    <r#"\(\*[^*]*"#> CommentRest,
    r#"//.*"#,
};


// make sure __proto__ is not considered a valid identifier
Illegal = "__proto__";


// Macros ////////////////////////////////////////////////////////////
Box<T>: Box<T> = {
    <T> => Box::new(<>),
}
SepList<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};
SepListOpt<T, Sep>: Vec<T> = {
    SepList<T, Sep>,
    => Vec::new(),
};

Spanned<T>: spans::Spanned<T> = {
    <l: @L> <val: T> <r: @R> => (val, ctx.span(l, r))
};
//////////////////////////////////////////////////////////////////////





VarOrLiteral: ast::Expr = {
    Spanned<Ident> =>
        match <>.0.as_str() {
            "false" | "true" => ast::Expr::Literal(ast::Literal::Bool, <>),
            "null" => ast::Expr::Literal(ast::Literal::Null, <>),
            _ => ast::Expr::Variable(<>)
        }
    ,

    Spanned<FloatLiteral> => ast::Expr::Literal(ast::Literal::Float, <>),
    Spanned<IntLiteral> => ast::Expr::Literal(ast::Literal::Int, <>),
    Spanned<StringLiteral> => ast::Expr::Literal(ast::Literal::Str, <>),
}

If: ast::Expr = {
    "if" <Spanned<Box<Expr>>> "then" <Box<Expr>> "else" <Box<Expr>> => ast::Expr::If(<>),
}


KeyPairPattern: (spans::Spanned<String>, Box<ast::LetPattern>) = {
    Comment* <name: Spanned<Ident>> "=" <pat: LetPattern> => (name, Box::new(pat)),
    Comment* <name: Spanned<Ident>> => (name.clone(), Box::new(ast::LetPattern::Var(name.0))),
}
LetPattern: ast::LetPattern = {
    <Ident> => ast::LetPattern::Var(<>),
    "{" <SepList<KeyPairPattern, ";">> "}" => ast::LetPattern::Record(<>),
}

FuncSub = "fun" <LetPattern> "->" <Box<Expr>>;
FuncDef: ast::Expr = {
    Spanned<FuncSub> => ast::Expr::FuncDef(<>),
}
Call: ast::Expr = {
    Spanned<Box<RefExpr>> Box<CallExpr> => {
        let ((lhs, span), rhs) = (<>);
        ast::Expr::Call(lhs, rhs, span)
    }
}


RecordExtension = {
    <Box<CallExpr>> "with"
}
KeyPairExpr: (spans::Spanned<String>, Box<ast::Expr>) = {
    Comment* <Spanned<Ident>> "=" <Box<Expr>>,
    Comment* <name: Spanned<Ident>> => (name.clone(), Box::new(ast::Expr::Variable(name))),
}
RecordSub = "{" <RecordExtension?> <SepListOpt<KeyPairExpr, ";">> "}";
Record: ast::Expr = {
    Spanned<RecordSub> => {
        let ((proto, fields), span) = <>;
        ast::Expr::Record(proto, fields, span)
    }
}
FieldAccess: ast::Expr = {
    <lhs: Box<SimpleExpr>> <rhs: Spanned<("." Ident)>> => ast::Expr::FieldAccess(lhs, (rhs.0).1, rhs.1),
}

Case: ast::Expr = {
    <Spanned<Tag>> <Box<CallExpr>> => ast::Expr::Case(<>),
}

MatchPattern: ast::MatchPattern = {
    Tag Ident => ast::MatchPattern::Case(<>),
    Ident => ast::MatchPattern::Wildcard(<>),
}
MatchArm = {
    Comment* "|" <Spanned<MatchPattern>> "->" <Box<CompareExpr>>,
}
MatchSub = "match" <Spanned<Box<Expr>>> "with" <MatchArm+>;
Match: ast::Expr = {
    MatchSub => {
        let ((param, span), arms) = <>;
        ast::Expr::Match(param, arms, span)
    }
}


LetLHS = {
    "let" <Ident> "=" <Box<Expr>>,
}
LetRHS = {
    "in" <Box<Expr>>,
}
Let: ast::Expr = {
    <LetLHS> <LetRHS> => ast::Expr::Let(<>),
}


LetRecDef = {
    <Ident> "=" Comment* <Box<FuncDef>>,
}
LetRecLHS = {
    "let" "rec" <SepList<LetRecDef, "and">>,
}
LetRec: ast::Expr = {
     <LetRecLHS> <LetRHS> => ast::Expr::LetRec(<>),
}


NewRef: ast::Expr = {
    Spanned<("ref" Box<CallExpr>)> => {
        let ((_, expr), span) = <>;
        ast::Expr::NewRef(expr, span)
    }
}
RefGet: ast::Expr = {
    "!" <Spanned<Box<RefExpr>>> => ast::Expr::RefGet(<>)
}
RefSet: ast::Expr = {
    <Spanned<Box<CallExpr>>> ":=" <Box<Expr>> => ast::Expr::RefSet(<>)
}


MultOpSub: (ast::OpType, ast::Op) = {
    "*" => (ast::OpType::IntOp, ast::Op::Mult),
    "/" => (ast::OpType::IntOp, ast::Op::Div),
    "%" => (ast::OpType::IntOp, ast::Op::Rem),
    "*." => (ast::OpType::FloatOp, ast::Op::Mult),
    "/." => (ast::OpType::FloatOp, ast::Op::Div),
    "%." => (ast::OpType::FloatOp, ast::Op::Rem),
}
MultOp: ast::Expr = {
    Spanned<(Spanned<Box<MultExpr>> MultOpSub Spanned<Box<CallExpr>>)> => {
        let ((lhs, op, rhs), span) = <>;
        ast::Expr::BinOp(lhs, rhs, op.0, op.1, span)
    },
}
AddOpSub: (ast::OpType, ast::Op) = {
    "+" => (ast::OpType::IntOp, ast::Op::Add),
    "-" => (ast::OpType::IntOp, ast::Op::Sub),
    "+." => (ast::OpType::FloatOp, ast::Op::Add),
    "-." => (ast::OpType::FloatOp, ast::Op::Sub),
    "^" => (ast::OpType::StrOp, ast::Op::Add),
}
AddOp: ast::Expr = {
    Spanned<(Spanned<Box<AddExpr>> AddOpSub Spanned<Box<MultExpr>>)> => {
        let ((lhs, op, rhs), span) = <>;
        ast::Expr::BinOp(lhs, rhs, op.0, op.1, span)
    },
}
CmpOpSub: (ast::OpType, ast::Op) = {
    "<" => (ast::OpType::IntOrFloatCmp, ast::Op::Lt),
    "<=" => (ast::OpType::IntOrFloatCmp, ast::Op::Lte),
    ">" => (ast::OpType::IntOrFloatCmp, ast::Op::Gt),
    ">=" => (ast::OpType::IntOrFloatCmp, ast::Op::Gte),

    "==" => (ast::OpType::AnyCmp, ast::Op::Eq),
    "!=" => (ast::OpType::AnyCmp, ast::Op::Neq),
}
CmpOp: ast::Expr = {
    Spanned<(Spanned<Box<AddExpr>> CmpOpSub Spanned<Box<AddExpr>>)> => {
        let ((lhs, op, rhs), span) = <>;
        ast::Expr::BinOp(lhs, rhs, op.0, op.1, span)
    },
}










RecordTypeExtension = <Box<Type>> "with";
KeyPairType = {
    <Spanned<Ident>> ":" <Box<Type>>,
}
RecordTypeSub = "{" <RecordTypeExtension?> <SepList<KeyPairType, ";">> "}";
RecordType: ast::TypeExpr = {
    Spanned<RecordTypeSub> => {
        let ((ext, fields), span) = <>;
        ast::TypeExpr::Record(ext, fields, span)
    }
}

CaseTypeExtension = <Box<Type>> "|";
VariantType = <Spanned<Tag>> "of" <Box<NoFunType>>;
CaseTypeSub = "[" <CaseTypeExtension?> <SepList<VariantType, "|">> "]";
CaseType: ast::TypeExpr = {
    Spanned<CaseTypeSub> => {
        let ((ext, cases), span) = <>;
        ast::TypeExpr::Case(ext, cases, span)
    }
}
FuncTypeSub = <Box<NoFunType>> "->" <Box<Type>>;
FuncType: ast::TypeExpr = {
    Spanned<FuncTypeSub> => ast::TypeExpr::Func(<>),
}
RefReadability: ast::Readability = {
    "readonly" "ref" => ast::Readability::ReadOnly,
    "writeonly" "ref" => ast::Readability::WriteOnly,
    "ref" => ast::Readability::ReadWrite,
}
RefType: ast::TypeExpr = {
    Box<NoFunType> Spanned<RefReadability> => ast::TypeExpr::Ref(<>),
}
QMark: spans::Span = Spanned<"?"> => <>.1;
NullableType: ast::TypeExpr = {
    Box<NoFunType> QMark => ast::TypeExpr::Nullable(<>),
}

TypeVar = "'" <Ident>;

NoFunType: ast::TypeExpr = {
    Spanned<Ident> => ast::TypeExpr::Ident(<>),
    <Box<NoFunType>> "as" <Spanned<TypeVar>> => ast::TypeExpr::Alias(<>),
    Spanned<TypeVar> => ast::TypeExpr::TypeVar(<>),

    RecordType,
    CaseType,
    RefType,
    NullableType,
    "(" <Type> ")",
}
Type = {
    NoFunType,
    FuncType,
}






SimpleExpr = {
    FieldAccess,
    Record,
    VarOrLiteral,
    "(" <Expr> ")",
    "(" <Box<Expr>> ":" <Type> ")" => ast::Expr::Typed(<>),
}
RefExpr = {
    SimpleExpr,
    RefGet,
}
CallExpr = {
    RefExpr,
    Call,
    Case,
    NewRef,
}
MultExpr = {
    CallExpr,
    MultOp,
}
AddExpr = {
    MultExpr,
    AddOp,
}
CompareExpr = {
    AddExpr,
    CmpOp,
}
TopLevelExpr = {
    CompareExpr,
    FuncDef,
    If,
    Let,
    LetRec,
    Match,
    RefSet,
}
Expr = {
    TopLevelExpr,
    Comment <Expr>,
}

TopLevelItem: ast::TopLevel = {
    <LetLHS> => ast::TopLevel::LetDef(<>),
    <LetRecLHS> => ast::TopLevel::LetRecDef(<>),
    <TopLevelExpr> => ast::TopLevel::Expr(<>),

    Comment <TopLevelItem>,
}

pub Script = {
   <SepList<TopLevelItem, ";">>
}
